package tomate

// file generated by
// github.com/mh-cbon/ggt
// do not edit

import (
	json "encoding/json"
)

// SimilarTomates implements a typed slice of *SimilarTomate
type SimilarTomates struct{ items []*SimilarTomate }

// NewSimilarTomates creates a new typed slice of *SimilarTomate
func NewSimilarTomates() *SimilarTomates {
	return &SimilarTomates{items: []*SimilarTomate{}}
}

// Push appends every *SimilarTomate
func (t *SimilarTomates) Push(x ...*SimilarTomate) *SimilarTomates {
	t.items = append(t.items, x...)
	return t
}

// Unshift prepends every *SimilarTomate
func (t *SimilarTomates) Unshift(x ...*SimilarTomate) *SimilarTomates {
	t.items = append(x, t.items...)
	return t
}

// Pop removes then returns the last *SimilarTomate.
func (t *SimilarTomates) Pop() *SimilarTomate {
	var ret *SimilarTomate
	if len(t.items) > 0 {
		ret = t.items[len(t.items)-1]
		t.items = append(t.items[:0], t.items[len(t.items)-1:]...)
	}
	return ret
}

// Shift removes then returns the first *SimilarTomate.
func (t *SimilarTomates) Shift() *SimilarTomate {
	var ret *SimilarTomate
	if len(t.items) > 0 {
		ret = t.items[0]
		t.items = append(t.items[:0], t.items[1:]...)
	}
	return ret
}

// Index of given *SimilarTomate. It must implements Ider interface.
func (t *SimilarTomates) Index(s *SimilarTomate) int {
	ret := -1
	for i, item := range t.items {
		if s.GetID() == item.GetID() {
			ret = i
			break
		}
	}
	return ret
}

// Contains returns true if s in is t.
func (t *SimilarTomates) Contains(s *SimilarTomate) bool {
	return t.Index(s) > -1
}

// RemoveAt removes a *SimilarTomate at index i.
func (t *SimilarTomates) RemoveAt(i int) bool {
	if i >= 0 && i < len(t.items) {
		t.items = append(t.items[:i], t.items[i+1:]...)
		return true
	}
	return false
}

// Remove removes given *SimilarTomate
func (t *SimilarTomates) Remove(s *SimilarTomate) bool {
	if i := t.Index(s); i > -1 {
		t.RemoveAt(i)
		return true
	}
	return false
}

// InsertAt adds given *SimilarTomate at index i
func (t *SimilarTomates) InsertAt(i int, s *SimilarTomate) *SimilarTomates {
	if i < 0 || i >= len(t.items) {
		return t
	}
	res := []*SimilarTomate{}
	res = append(res, t.items[:0]...)
	res = append(res, s)
	res = append(res, t.items[i:]...)
	t.items = res
	return t
}

// Splice removes and returns a slice of *SimilarTomate, starting at start, ending at start+length.
// If any s is provided, they are inserted in place of the removed slice.
func (t *SimilarTomates) Splice(start int, length int, s ...*SimilarTomate) []*SimilarTomate {
	var ret []*SimilarTomate
	for i := 0; i < len(t.items); i++ {
		if i >= start && i < start+length {
			ret = append(ret, t.items[i])
		}
	}
	if start >= 0 && start+length <= len(t.items) && start+length >= 0 {
		t.items = append(
			t.items[:start],
			append(s,
				t.items[start+length:]...,
			)...,
		)
	}
	return ret
}

// Slice returns a copied slice of *SimilarTomate, starting at start, ending at start+length.
func (t *SimilarTomates) Slice(start int, length int) []*SimilarTomate {
	var ret []*SimilarTomate
	if start >= 0 && start+length <= len(t.items) && start+length >= 0 {
		ret = t.items[start : start+length]
	}
	return ret
}

// Reverse the slice.
func (t *SimilarTomates) Reverse() *SimilarTomates {
	for i, j := 0, len(t.items)-1; i < j; i, j = i+1, j-1 {
		t.items[i], t.items[j] = t.items[j], t.items[i]
	}
	return t
}

// Len of the slice.
func (t *SimilarTomates) Len() int {
	return len(t.items)
}

// Set the slice.
func (t *SimilarTomates) Set(x []*SimilarTomate) *SimilarTomates {
	t.items = append(t.items[:0], x...)
	return t
}

// Get the slice.
func (t *SimilarTomates) Get() []*SimilarTomate {
	return t.items
}

// At return the item at index i.
func (t *SimilarTomates) At(i int) *SimilarTomate {
	return t.items[i]
}

// Filter return a new SimilarTomates with all items satisfying f.
func (t *SimilarTomates) Filter(filters ...func(*SimilarTomate) bool) *SimilarTomates {
	ret := NewSimilarTomates()
	for _, i := range t.items {
		ok := true
		for _, f := range filters {
			ok = ok && f(i)
			if !ok {
				break
			}
		}
		if ok {
			ret.Push(i)
		}
	}
	return ret
}

// Map return a new SimilarTomates of each items modified by f.
func (t *SimilarTomates) Map(mappers ...func(*SimilarTomate) *SimilarTomate) *SimilarTomates {
	ret := NewSimilarTomates()
	for _, i := range t.items {
		val := i
		for _, m := range mappers {
			val = m(val)
			if val == nil {
				break
			}
		}
		if val != nil {
			ret.Push(val)
		}
	}
	return ret
}

// First returns the first value or default.
func (t *SimilarTomates) First() *SimilarTomate {
	var ret *SimilarTomate
	if len(t.items) > 0 {
		ret = t.items[0]
	}
	return ret
}

// Last returns the last value or default.
func (t *SimilarTomates) Last() *SimilarTomate {
	var ret *SimilarTomate
	if len(t.items) > 0 {
		ret = t.items[len(t.items)-1]
	}
	return ret
}

// Empty returns true if the slice is empty.
func (t *SimilarTomates) Empty() bool {
	return len(t.items) == 0
}

// NotEmpty returns true if the slice is not empty.
func (t *SimilarTomates) NotEmpty() bool {
	return len(t.items) > 0
}

// Transact execute one op.
func (t *SimilarTomates) Transact(F ...func(*SimilarTomates)) {
	for _, f := range F {
		f(t)
	}
}

//UnmarshalJSON JSON unserializes SimilarTomates
func (t *SimilarTomates) UnmarshalJSON(b []byte) error {
	var items []*SimilarTomate
	if err := json.Unmarshal(b, &items); err != nil {
		return err
	}
	t.items = items
	return nil
}

//MarshalJSON JSON serializes SimilarTomates
func (t *SimilarTomates) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.items)
}

// SimilarTomatesContract are the requirements of SimilarTomates
type SimilarTomatesContract interface {
	Push(x ...*SimilarTomate) *SimilarTomates
	Unshift(x ...*SimilarTomate) *SimilarTomates
	Pop() *SimilarTomate
	Shift() *SimilarTomate
	Index(s *SimilarTomate) int
	Contains(s *SimilarTomate) bool
	RemoveAt(i int) bool
	Remove(s *SimilarTomate) bool
	InsertAt(i int, s *SimilarTomate) *SimilarTomates
	Splice(start int, length int, s ...*SimilarTomate) []*SimilarTomate
	Slice(start int, length int) []*SimilarTomate
	Reverse() *SimilarTomates
	Set(x []*SimilarTomate) *SimilarTomates
	Get() []*SimilarTomate
	At(i int) *SimilarTomate
	Filter(filters ...func(*SimilarTomate) bool) *SimilarTomates
	Map(mappers ...func(*SimilarTomate) *SimilarTomate) *SimilarTomates
	First() *SimilarTomate
	Last() *SimilarTomate
	Transact(...func(*SimilarTomates))
	Len() int
	Empty() bool
	NotEmpty() bool
}

// FilterSimilarTomates provides filters for a struct.
var FilterSimilarTomates = struct {
	ByID           func(...string) func(*SimilarTomate) bool
	NotID          func(...string) func(*SimilarTomate) bool
	ByColor        func(...string) func(*SimilarTomate) bool
	NotColor       func(...string) func(*SimilarTomate) bool
	BySimilarity   func(...float64) func(*SimilarTomate) bool
	NotSimilarity  func(...float64) func(*SimilarTomate) bool
	GtSimilarity   func(...float64) func(*SimilarTomate) bool
	GtEqSimilarity func(...float64) func(*SimilarTomate) bool
	LtSimilarity   func(...float64) func(*SimilarTomate) bool
	LtEqSimilarity func(...float64) func(*SimilarTomate) bool
}{
	ByID: func(all ...string) func(*SimilarTomate) bool {
		return func(o *SimilarTomate) bool {
			for _, v := range all {
				if o.ID == v {
					return true
				}
			}
			return false
		}
	},
	NotID: func(all ...string) func(*SimilarTomate) bool {
		return func(o *SimilarTomate) bool {
			for _, v := range all {
				if o.ID == v {
					return false
				}
			}
			return true
		}
	},
	ByColor: func(all ...string) func(*SimilarTomate) bool {
		return func(o *SimilarTomate) bool {
			for _, v := range all {
				if o.Color == v {
					return true
				}
			}
			return false
		}
	},
	NotColor: func(all ...string) func(*SimilarTomate) bool {
		return func(o *SimilarTomate) bool {
			for _, v := range all {
				if o.Color == v {
					return false
				}
			}
			return true
		}
	},
	BySimilarity: func(all ...float64) func(*SimilarTomate) bool {
		return func(o *SimilarTomate) bool {
			for _, v := range all {
				if o.Similarity == v {
					return true
				}
			}
			return false
		}
	},
	NotSimilarity: func(all ...float64) func(*SimilarTomate) bool {
		return func(o *SimilarTomate) bool {
			for _, v := range all {
				if o.Similarity == v {
					return false
				}
			}
			return true
		}
	},
	GtSimilarity: func(all ...float64) func(*SimilarTomate) bool {
		return func(o *SimilarTomate) bool {
			for _, v := range all {
				if o.Similarity > v {
					return true
				}
			}
			return false
		}
	},
	GtEqSimilarity: func(all ...float64) func(*SimilarTomate) bool {
		return func(o *SimilarTomate) bool {
			for _, v := range all {
				if o.Similarity >= v {
					return true
				}
			}
			return false
		}
	},
	LtSimilarity: func(all ...float64) func(*SimilarTomate) bool {
		return func(o *SimilarTomate) bool {
			for _, v := range all {
				if o.Similarity < v {
					return true
				}
			}
			return false
		}
	},
	LtEqSimilarity: func(all ...float64) func(*SimilarTomate) bool {
		return func(o *SimilarTomate) bool {
			for _, v := range all {
				if o.Similarity <= v {
					return true
				}
			}
			return false
		}
	},
}

// SetterSimilarTomates provides sets properties.
var SetterSimilarTomates = struct {
	SetID         func(string) func(*SimilarTomate) *SimilarTomate
	SetColor      func(string) func(*SimilarTomate) *SimilarTomate
	SetSimilarity func(float64) func(*SimilarTomate) *SimilarTomate
}{
	SetID: func(v string) func(*SimilarTomate) *SimilarTomate {
		return func(o *SimilarTomate) *SimilarTomate {
			o.ID = v
			return o
		}
	},
	SetColor: func(v string) func(*SimilarTomate) *SimilarTomate {
		return func(o *SimilarTomate) *SimilarTomate {
			o.Color = v
			return o
		}
	},
	SetSimilarity: func(v float64) func(*SimilarTomate) *SimilarTomate {
		return func(o *SimilarTomate) *SimilarTomate {
			o.Similarity = v
			return o
		}
	},
}
