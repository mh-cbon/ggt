package capable

// file generated by
// github.com/mh-cbon/ggt
// do not edit

import (
	ggt "github.com/mh-cbon/ggt/lib"
	finder "github.com/mh-cbon/service-finder"
	"io"
	"mime/multipart"
	"net/http"
	"strconv"
)

var xx9bbbadb296eb19978d160636de7433defc9f993f = strconv.Atoi
var xxc16c3d8f861e70ce7bb3019f599725ac7de90b02 = io.Copy
var xx6aee1a663c6548182a6d83501d6ea0cc7438dc18 = http.StatusOK

// RPCFile is an httper of File.
// File ...
type RPCFile struct {
	embed    File
	Services finder.ServiceFinder
	Log      ggt.HTTPLogger
	Session  ggt.SessionStoreProvider
	Upload   ggt.Uploader
}

// NewRPCFile constructs an httper of File
func NewRPCFile(embed File) *RPCFile {
	ret := &RPCFile{
		embed:    embed,
		Services: finder.New(),
		Log:      &ggt.VoidLog{},
		Session:  &ggt.VoidSession{},
		Upload:   &ggt.FileProvider{},
	}
	ret.Log.Handle(nil, nil, nil, "constructor", "RPCFile")
	return ret
}

// ReadOneFile invoke File.ReadOneFile using the request body as a json payload.
// ReadOneFile ...
func (t *RPCFile) ReadOneFile(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RPCFile", "ReadOneFile")
	var fileName io.Reader
	{
		if fheaders, ok := r.MultipartForm.File["name"]; ok {
			for _, hdr := range fheaders {
				var infile multipart.File
				infile, uploadErr := hdr.Open()

				if uploadErr != nil {

					t.Log.Handle(w, r, uploadErr, "req", "file", "open", "error", "RPCFile", "ReadOneFile")
					http.Error(w, uploadErr.Error(), http.StatusInternalServerError)

					return
				}

				defer infile.Close()
				fileName = infile.(io.Reader)
				break
			}
		}
	}

	t.embed.ReadOneFile(fileName)

	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RPCFile", "ReadOneFile")

}

// ReadOneTmpFile invoke File.ReadOneTmpFile using the request body as a json payload.
// ReadOneTmpFile ...
func (t *RPCFile) ReadOneTmpFile(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RPCFile", "ReadOneTmpFile")
	var fileName ggt.File
	{
		f, uploadErr := t.Upload.Get(r, w, "name")

		if uploadErr != nil {

			t.Log.Handle(w, r, uploadErr, "req", "file", "open", "error", "RPCFile", "ReadOneTmpFile")
			http.Error(w, uploadErr.Error(), http.StatusInternalServerError)

			return
		}

		fileName = f
	}

	t.embed.ReadOneTmpFile(fileName)

	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RPCFile", "ReadOneTmpFile")

}

// ReadMany invoke File.ReadMany using the request body as a json payload.
// ReadMany ...
func (t *RPCFile) ReadMany(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RPCFile", "ReadMany")
	var fileName ggt.File
	{
		f, uploadErr := t.Upload.Get(r, w, "name")

		if uploadErr != nil {

			t.Log.Handle(w, r, uploadErr, "req", "file", "open", "error", "RPCFile", "ReadMany")
			http.Error(w, uploadErr.Error(), http.StatusInternalServerError)

			return
		}

		fileName = f
	}
	var fileName2 ggt.File
	{
		f, uploadErr := t.Upload.Get(r, w, "name2")

		if uploadErr != nil {

			t.Log.Handle(w, r, uploadErr, "req", "file", "open", "error", "RPCFile", "ReadMany")
			http.Error(w, uploadErr.Error(), http.StatusInternalServerError)

			return
		}

		fileName2 = f
	}

	t.embed.ReadMany(fileName, fileName2)

	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RPCFile", "ReadMany")

}

// ReadSlice invoke File.ReadSlice using the request body as a json payload.
// ReadSlice ...
func (t *RPCFile) ReadSlice(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RPCFile", "ReadSlice")
	var fileName []io.Reader
	{
		if fheaders, ok := r.MultipartForm.File["name"]; ok {
			for _, hdr := range fheaders {
				var infile multipart.File
				infile, uploadErr := hdr.Open()

				if uploadErr != nil {

					t.Log.Handle(w, r, uploadErr, "req", "file", "open", "error", "RPCFile", "ReadSlice")
					http.Error(w, uploadErr.Error(), http.StatusInternalServerError)

					return
				}

				defer infile.Close()
				fileName = append(fileName, infile.(io.Reader))
			}
		}
	}
	var fileName2 []ggt.File
	{
		f, uploadErr := t.Upload.GetSlice(r, w, "name2")

		if uploadErr != nil {

			t.Log.Handle(w, r, uploadErr, "req", "file", "open", "error", "RPCFile", "ReadSlice")
			http.Error(w, uploadErr.Error(), http.StatusInternalServerError)

			return
		}

		fileName2 = f
	}

	t.embed.ReadSlice(fileName, fileName2)

	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RPCFile", "ReadSlice")

}

// ReadAll invoke File.ReadAll using the request body as a json payload.
// ReadAll ...
func (t *RPCFile) ReadAll(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RPCFile", "ReadAll")
	var fileValues []io.Reader
	{
		for _, fheaders := range r.MultipartForm.File {
			for _, hdr := range fheaders {
				var upload multipart.File
				upload, uploadErr := hdr.Open()

				if uploadErr != nil {

					t.Log.Handle(w, r, uploadErr, "req", "file", "open", "error", "RPCFile", "ReadAll")
					http.Error(w, uploadErr.Error(), http.StatusInternalServerError)

					return
				}

				defer upload.Close()
				fileValues = append(fileValues, upload.(io.Reader))
			}
		}
	}

	t.embed.ReadAll(fileValues)

	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RPCFile", "ReadAll")

}

// ReadAll2 invoke File.ReadAll2 using the request body as a json payload.
// ReadAll2 ...
func (t *RPCFile) ReadAll2(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RPCFile", "ReadAll2")
	var fileValues []ggt.File
	{
		f, uploadErr := t.Upload.GetAll(r, w)

		if uploadErr != nil {

			t.Log.Handle(w, r, uploadErr, "req", "file", "open", "error", "RPCFile", "ReadAll2")
			http.Error(w, uploadErr.Error(), http.StatusInternalServerError)

			return
		}

		fileValues = f
	}

	t.embed.ReadAll2(fileValues)

	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RPCFile", "ReadAll2")

}

// WriteFile invoke File.WriteFile using the request body as a json payload.
// WriteFile ...
func (t *RPCFile) WriteFile(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RPCFile", "WriteFile")

	fileResBody, fileResName, fileResContentType := t.embed.WriteFile()

	w.Header().Set("Content-Disposition", "attachment; filename="+fileResName)

	w.Header().Set("Content-Type", fileResContentType)

	defer func() {
		if x, ok := fileResBody.(io.Closer); ok {
			closeErr := x.Close()

			if closeErr != nil {

				t.Log.Handle(w, r, closeErr, "res", "file", "error", "RPCFile", "WriteFile")
				http.Error(w, closeErr.Error(), http.StatusInternalServerError)

				return
			}

		}
	}()

	_, copyErr := io.Copy(w, fileResBody)

	if copyErr != nil {

		t.Log.Handle(w, r, copyErr, "res", "file", "error", "RPCFile", "WriteFile")
		http.Error(w, copyErr.Error(), http.StatusInternalServerError)

		return
	}

	t.Log.Handle(w, r, nil, "end", "RPCFile", "WriteFile")

}

// WriteFile2 invoke File.WriteFile2 using the request body as a json payload.
// WriteFile2 ...
func (t *RPCFile) WriteFile2(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RPCFile", "WriteFile2")

	fileResBody := t.embed.WriteFile2()

	if fileResBody != nil {

		w.Header().Set("Content-Disposition", "attachment; filename="+fileResBody.AttachmentName())

		w.Header().Set("Content-Type", fileResBody.ContentType())

		defer func() {
			closeErr := fileResBody.Close()

			if closeErr != nil {

				t.Log.Handle(w, r, closeErr, "res", "file", "error", "RPCFile", "WriteFile2")
				http.Error(w, closeErr.Error(), http.StatusInternalServerError)

				return
			}

		}()

		_, copyErr := io.Copy(w, fileResBody.Fd())

		if copyErr != nil {

			t.Log.Handle(w, r, copyErr, "res", "file", "error", "RPCFile", "WriteFile2")
			http.Error(w, copyErr.Error(), http.StatusInternalServerError)

			return
		}

	}

	t.Log.Handle(w, r, nil, "end", "RPCFile", "WriteFile2")

}

// WriteFile3 invoke File.WriteFile3 using the request body as a json payload.
// WriteFile3 ...
func (t *RPCFile) WriteFile3(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RPCFile", "WriteFile3")

	fileResBody := t.embed.WriteFile3()

	w.Header().Set("Content-Disposition", "attachment; filename="+fileResBody.AttachmentName())

	w.Header().Set("Content-Type", fileResBody.ContentType())

	defer func() {
		closeErr := fileResBody.Close()

		if closeErr != nil {

			t.Log.Handle(w, r, closeErr, "res", "file", "error", "RPCFile", "WriteFile3")
			http.Error(w, closeErr.Error(), http.StatusInternalServerError)

			return
		}

	}()

	_, copyErr := io.Copy(w, fileResBody.Fd())

	if copyErr != nil {

		t.Log.Handle(w, r, copyErr, "res", "file", "error", "RPCFile", "WriteFile3")
		http.Error(w, copyErr.Error(), http.StatusInternalServerError)

		return
	}

	t.Log.Handle(w, r, nil, "end", "RPCFile", "WriteFile3")

}

// RPCFileDescriptor describe a *RPCFile
type RPCFileDescriptor struct {
	ggt.TypeDescriptor
	about                *RPCFile
	methodReadOneFile    *ggt.MethodDescriptor
	methodReadOneTmpFile *ggt.MethodDescriptor
	methodReadMany       *ggt.MethodDescriptor
	methodReadSlice      *ggt.MethodDescriptor
	methodReadAll        *ggt.MethodDescriptor
	methodReadAll2       *ggt.MethodDescriptor
	methodWriteFile      *ggt.MethodDescriptor
	methodWriteFile2     *ggt.MethodDescriptor
	methodWriteFile3     *ggt.MethodDescriptor
}

// NewRPCFileDescriptor describe a *RPCFile
func NewRPCFileDescriptor(about *RPCFile) *RPCFileDescriptor {
	ret := &RPCFileDescriptor{about: about}
	ret.methodReadOneFile = &ggt.MethodDescriptor{
		Name:    "ReadOneFile",
		Handler: about.ReadOneFile,
		Route:   "ReadOneFile",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodReadOneFile)
	ret.methodReadOneTmpFile = &ggt.MethodDescriptor{
		Name:    "ReadOneTmpFile",
		Handler: about.ReadOneTmpFile,
		Route:   "ReadOneTmpFile",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodReadOneTmpFile)
	ret.methodReadMany = &ggt.MethodDescriptor{
		Name:    "ReadMany",
		Handler: about.ReadMany,
		Route:   "ReadMany",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodReadMany)
	ret.methodReadSlice = &ggt.MethodDescriptor{
		Name:    "ReadSlice",
		Handler: about.ReadSlice,
		Route:   "ReadSlice",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodReadSlice)
	ret.methodReadAll = &ggt.MethodDescriptor{
		Name:    "ReadAll",
		Handler: about.ReadAll,
		Route:   "ReadAll",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodReadAll)
	ret.methodReadAll2 = &ggt.MethodDescriptor{
		Name:    "ReadAll2",
		Handler: about.ReadAll2,
		Route:   "ReadAll2",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodReadAll2)
	ret.methodWriteFile = &ggt.MethodDescriptor{
		Name:    "WriteFile",
		Handler: about.WriteFile,
		Route:   "WriteFile",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodWriteFile)
	ret.methodWriteFile2 = &ggt.MethodDescriptor{
		Name:    "WriteFile2",
		Handler: about.WriteFile2,
		Route:   "WriteFile2",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodWriteFile2)
	ret.methodWriteFile3 = &ggt.MethodDescriptor{
		Name:    "WriteFile3",
		Handler: about.WriteFile3,
		Route:   "WriteFile3",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodWriteFile3)
	return ret
}

// ReadOneFile returns a MethodDescriptor
func (t *RPCFileDescriptor) ReadOneFile() *ggt.MethodDescriptor { return t.methodReadOneFile }

// ReadOneTmpFile returns a MethodDescriptor
func (t *RPCFileDescriptor) ReadOneTmpFile() *ggt.MethodDescriptor { return t.methodReadOneTmpFile }

// ReadMany returns a MethodDescriptor
func (t *RPCFileDescriptor) ReadMany() *ggt.MethodDescriptor { return t.methodReadMany }

// ReadSlice returns a MethodDescriptor
func (t *RPCFileDescriptor) ReadSlice() *ggt.MethodDescriptor { return t.methodReadSlice }

// ReadAll returns a MethodDescriptor
func (t *RPCFileDescriptor) ReadAll() *ggt.MethodDescriptor { return t.methodReadAll }

// ReadAll2 returns a MethodDescriptor
func (t *RPCFileDescriptor) ReadAll2() *ggt.MethodDescriptor { return t.methodReadAll2 }

// WriteFile returns a MethodDescriptor
func (t *RPCFileDescriptor) WriteFile() *ggt.MethodDescriptor { return t.methodWriteFile }

// WriteFile2 returns a MethodDescriptor
func (t *RPCFileDescriptor) WriteFile2() *ggt.MethodDescriptor { return t.methodWriteFile2 }

// WriteFile3 returns a MethodDescriptor
func (t *RPCFileDescriptor) WriteFile3() *ggt.MethodDescriptor { return t.methodWriteFile3 }
