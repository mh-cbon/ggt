package capable

// file generated by
// github.com/mh-cbon/ggt
// do not edit

import (
	json "encoding/json"
	ggt "github.com/mh-cbon/ggt/lib"
	"io"
	"net/http"
	"strconv"
)

var xx9bbbadb296eb19978d160636de7433defc9f993f = strconv.Atoi
var xxc16c3d8f861e70ce7bb3019f599725ac7de90b02 = io.Copy
var xx6aee1a663c6548182a6d83501d6ea0cc7438dc18 = http.StatusOK

// RPCFile is an httper of File.
// File ...
type RPCFile struct {
	embed   File
	Log     ggt.HTTPLogger
	Session ggt.SessionStoreProvider
	Upload  ggt.Uploader
}

// NewRPCFile constructs an httper of File
func NewRPCFile(embed File) *RPCFile {
	ret := &RPCFile{
		embed:   embed,
		Log:     &ggt.VoidLog{},
		Session: &ggt.VoidSession{},
		Upload:  &ggt.FileProvider{},
	}
	ret.Log.Handle(nil, nil, nil, "constructor", "RPCFile")
	return ret
}

// ReadOneFile invoke File.ReadOneFile using the request body as a json payload.
// ReadOneFile ...
func (t *RPCFile) ReadOneFile(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RPCFile", "ReadOneFile")

	{
		err := r.ParseForm()

		if err != nil {

			t.Log.Handle(w, r, err, "parseform", "error", "RPCFile", "ReadOneFile")
			http.Error(w, err.Error(), http.StatusInternalServerError)

			return
		}

		uploadErr := t.Upload.Check(r, w)

		if uploadErr != nil {

			t.Log.Handle(w, r, uploadErr, "max-size", "error", "RPCFile", "ReadOneFile")
			http.Error(w, uploadErr.Error(), http.StatusInternalServerError)

			return
		}

	}
	input := struct {
		Arg0 io.Reader
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)

	if decErr != nil {

		t.Log.Handle(w, r, decErr, "req", "json", "decode", "error", "RPCFile", "ReadOneFile")
		http.Error(w, decErr.Error(), http.StatusInternalServerError)

		return
	}

	t.embed.ReadOneFile(input.Arg0)

	t.Log.Handle(w, r, nil, "end", "RPCFile", "ReadOneFile")
}

// ReadOneTmpFile invoke File.ReadOneTmpFile using the request body as a json payload.
// ReadOneTmpFile ...
func (t *RPCFile) ReadOneTmpFile(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RPCFile", "ReadOneTmpFile")

	{
		err := r.ParseForm()

		if err != nil {

			t.Log.Handle(w, r, err, "parseform", "error", "RPCFile", "ReadOneTmpFile")
			http.Error(w, err.Error(), http.StatusInternalServerError)

			return
		}

		uploadErr := t.Upload.Check(r, w)

		if uploadErr != nil {

			t.Log.Handle(w, r, uploadErr, "max-size", "error", "RPCFile", "ReadOneTmpFile")
			http.Error(w, uploadErr.Error(), http.StatusInternalServerError)

			return
		}

	}
	input := struct {
		Arg0 ggt.File
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)

	if decErr != nil {

		t.Log.Handle(w, r, decErr, "req", "json", "decode", "error", "RPCFile", "ReadOneTmpFile")
		http.Error(w, decErr.Error(), http.StatusInternalServerError)

		return
	}

	t.embed.ReadOneTmpFile(input.Arg0)

	t.Log.Handle(w, r, nil, "end", "RPCFile", "ReadOneTmpFile")
}

// ReadMany invoke File.ReadMany using the request body as a json payload.
// ReadMany ...
func (t *RPCFile) ReadMany(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RPCFile", "ReadMany")

	{
		err := r.ParseForm()

		if err != nil {

			t.Log.Handle(w, r, err, "parseform", "error", "RPCFile", "ReadMany")
			http.Error(w, err.Error(), http.StatusInternalServerError)

			return
		}

		uploadErr := t.Upload.Check(r, w)

		if uploadErr != nil {

			t.Log.Handle(w, r, uploadErr, "max-size", "error", "RPCFile", "ReadMany")
			http.Error(w, uploadErr.Error(), http.StatusInternalServerError)

			return
		}

	}
	input := struct {
		Arg0 ggt.File
		Arg1 ggt.File
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)

	if decErr != nil {

		t.Log.Handle(w, r, decErr, "req", "json", "decode", "error", "RPCFile", "ReadMany")
		http.Error(w, decErr.Error(), http.StatusInternalServerError)

		return
	}

	t.embed.ReadMany(input.Arg0, input.Arg1)

	t.Log.Handle(w, r, nil, "end", "RPCFile", "ReadMany")
}

// ReadSlice invoke File.ReadSlice using the request body as a json payload.
// ReadSlice ...
func (t *RPCFile) ReadSlice(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RPCFile", "ReadSlice")

	{
		err := r.ParseForm()

		if err != nil {

			t.Log.Handle(w, r, err, "parseform", "error", "RPCFile", "ReadSlice")
			http.Error(w, err.Error(), http.StatusInternalServerError)

			return
		}

		uploadErr := t.Upload.Check(r, w)

		if uploadErr != nil {

			t.Log.Handle(w, r, uploadErr, "max-size", "error", "RPCFile", "ReadSlice")
			http.Error(w, uploadErr.Error(), http.StatusInternalServerError)

			return
		}

	}
	input := struct {
		Arg0 []io.Reader
		Arg1 []ggt.File
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)

	if decErr != nil {

		t.Log.Handle(w, r, decErr, "req", "json", "decode", "error", "RPCFile", "ReadSlice")
		http.Error(w, decErr.Error(), http.StatusInternalServerError)

		return
	}

	t.embed.ReadSlice(input.Arg0, input.Arg1)

	t.Log.Handle(w, r, nil, "end", "RPCFile", "ReadSlice")
}

// ReadAll invoke File.ReadAll using the request body as a json payload.
// ReadAll ...
func (t *RPCFile) ReadAll(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RPCFile", "ReadAll")

	{
		err := r.ParseForm()

		if err != nil {

			t.Log.Handle(w, r, err, "parseform", "error", "RPCFile", "ReadAll")
			http.Error(w, err.Error(), http.StatusInternalServerError)

			return
		}

		uploadErr := t.Upload.Check(r, w)

		if uploadErr != nil {

			t.Log.Handle(w, r, uploadErr, "max-size", "error", "RPCFile", "ReadAll")
			http.Error(w, uploadErr.Error(), http.StatusInternalServerError)

			return
		}

	}
	input := struct {
		Arg0 []io.Reader
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)

	if decErr != nil {

		t.Log.Handle(w, r, decErr, "req", "json", "decode", "error", "RPCFile", "ReadAll")
		http.Error(w, decErr.Error(), http.StatusInternalServerError)

		return
	}

	t.embed.ReadAll(input.Arg0)

	t.Log.Handle(w, r, nil, "end", "RPCFile", "ReadAll")
}

// ReadAll2 invoke File.ReadAll2 using the request body as a json payload.
// ReadAll2 ...
func (t *RPCFile) ReadAll2(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RPCFile", "ReadAll2")

	{
		err := r.ParseForm()

		if err != nil {

			t.Log.Handle(w, r, err, "parseform", "error", "RPCFile", "ReadAll2")
			http.Error(w, err.Error(), http.StatusInternalServerError)

			return
		}

		uploadErr := t.Upload.Check(r, w)

		if uploadErr != nil {

			t.Log.Handle(w, r, uploadErr, "max-size", "error", "RPCFile", "ReadAll2")
			http.Error(w, uploadErr.Error(), http.StatusInternalServerError)

			return
		}

	}
	input := struct {
		Arg0 []ggt.File
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)

	if decErr != nil {

		t.Log.Handle(w, r, decErr, "req", "json", "decode", "error", "RPCFile", "ReadAll2")
		http.Error(w, decErr.Error(), http.StatusInternalServerError)

		return
	}

	t.embed.ReadAll2(input.Arg0)

	t.Log.Handle(w, r, nil, "end", "RPCFile", "ReadAll2")
}

// RPCFileDescriptor describe a *RPCFile
type RPCFileDescriptor struct {
	ggt.TypeDescriptor
	about                *RPCFile
	methodReadOneFile    *ggt.MethodDescriptor
	methodReadOneTmpFile *ggt.MethodDescriptor
	methodReadMany       *ggt.MethodDescriptor
	methodReadSlice      *ggt.MethodDescriptor
	methodReadAll        *ggt.MethodDescriptor
	methodReadAll2       *ggt.MethodDescriptor
}

// NewRPCFileDescriptor describe a *RPCFile
func NewRPCFileDescriptor(about *RPCFile) *RPCFileDescriptor {
	ret := &RPCFileDescriptor{about: about}
	ret.methodReadOneFile = &ggt.MethodDescriptor{
		Name:    "ReadOneFile",
		Handler: about.ReadOneFile,
		Route:   "ReadOneFile",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodReadOneFile)
	ret.methodReadOneTmpFile = &ggt.MethodDescriptor{
		Name:    "ReadOneTmpFile",
		Handler: about.ReadOneTmpFile,
		Route:   "ReadOneTmpFile",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodReadOneTmpFile)
	ret.methodReadMany = &ggt.MethodDescriptor{
		Name:    "ReadMany",
		Handler: about.ReadMany,
		Route:   "ReadMany",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodReadMany)
	ret.methodReadSlice = &ggt.MethodDescriptor{
		Name:    "ReadSlice",
		Handler: about.ReadSlice,
		Route:   "ReadSlice",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodReadSlice)
	ret.methodReadAll = &ggt.MethodDescriptor{
		Name:    "ReadAll",
		Handler: about.ReadAll,
		Route:   "ReadAll",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodReadAll)
	ret.methodReadAll2 = &ggt.MethodDescriptor{
		Name:    "ReadAll2",
		Handler: about.ReadAll2,
		Route:   "ReadAll2",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodReadAll2)
	return ret
}

// ReadOneFile returns a MethodDescriptor
func (t *RPCFileDescriptor) ReadOneFile() *ggt.MethodDescriptor { return t.methodReadOneFile }

// ReadOneTmpFile returns a MethodDescriptor
func (t *RPCFileDescriptor) ReadOneTmpFile() *ggt.MethodDescriptor { return t.methodReadOneTmpFile }

// ReadMany returns a MethodDescriptor
func (t *RPCFileDescriptor) ReadMany() *ggt.MethodDescriptor { return t.methodReadMany }

// ReadSlice returns a MethodDescriptor
func (t *RPCFileDescriptor) ReadSlice() *ggt.MethodDescriptor { return t.methodReadSlice }

// ReadAll returns a MethodDescriptor
func (t *RPCFileDescriptor) ReadAll() *ggt.MethodDescriptor { return t.methodReadAll }

// ReadAll2 returns a MethodDescriptor
func (t *RPCFileDescriptor) ReadAll2() *ggt.MethodDescriptor { return t.methodReadAll2 }
