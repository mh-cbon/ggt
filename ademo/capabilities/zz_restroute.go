package capable

// file generated by
// github.com/mh-cbon/ggt
// do not edit

import (
	"github.com/gorilla/mux"
	ggt "github.com/mh-cbon/ggt/lib"
	finder "github.com/mh-cbon/service-finder"
	"io"
	"net/http"
	"strconv"
)

var xx11d993c04acefa26da5321978096985c2062b454 = strconv.Atoi
var xx93a4423d46d788cc56aa3f0ffe947e7fc608756f = io.Copy
var xxb47dda5b25301614e990ea2bc6deb11aaab869c4 = http.StatusOK

// RestRoute is an httper of Route.
// Route ...
type RestRoute struct {
	embed    Route
	Services finder.ServiceFinder
	Log      ggt.HTTPLogger
	Session  ggt.SessionStoreProvider
	Upload   ggt.Uploader
}

// NewRestRoute constructs an httper of Route
func NewRestRoute(embed Route) *RestRoute {
	ret := &RestRoute{
		embed:    embed,
		Services: finder.New(),
		Log:      &ggt.VoidLog{},
		Session:  &ggt.VoidSession{},
		Upload:   &ggt.FileProvider{},
	}
	ret.Log.Handle(nil, nil, nil, "constructor", "RestRoute")
	return ret
}

// GetAll invoke Route.GetAll using the request body as a json payload.
// GetAll values from the route.
func (t *RestRoute) GetAll(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RestRoute", "GetAll")

	xxRouteVars := mux.Vars(r)
	routeValues := xxRouteVars

	t.embed.GetAll(routeValues)

	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RestRoute", "GetAll")

}

// GetOne invoke Route.GetOne using the request body as a json payload.
// GetOne value from the route.
func (t *RestRoute) GetOne(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RestRoute", "GetOne")

	xxRouteVars := mux.Vars(r)
	var routeArg1 string
	if _, ok := xxRouteVars["arg1"]; ok {
		xxTmprouteArg1 := xxRouteVars["arg1"]
		t.Log.Handle(w, r, nil, "input", "route", "arg1", xxTmprouteArg1, "RestRoute", "GetOne")
		routeArg1 = xxTmprouteArg1
	}

	t.embed.GetOne(routeArg1)

	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RestRoute", "GetOne")

}

// GetMany invoke Route.GetMany using the request body as a json payload.
// GetMany values from the route.
func (t *RestRoute) GetMany(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RestRoute", "GetMany")

	xxRouteVars := mux.Vars(r)
	var routeArg1 string
	if _, ok := xxRouteVars["arg1"]; ok {
		xxTmprouteArg1 := xxRouteVars["arg1"]
		t.Log.Handle(w, r, nil, "input", "route", "arg1", xxTmprouteArg1, "RestRoute", "GetMany")
		routeArg1 = xxTmprouteArg1
	}
	var routeArg2 string
	if _, ok := xxRouteVars["arg2"]; ok {
		xxTmprouteArg2 := xxRouteVars["arg2"]
		t.Log.Handle(w, r, nil, "input", "route", "arg2", xxTmprouteArg2, "RestRoute", "GetMany")
		routeArg2 = xxTmprouteArg2
	}

	t.embed.GetMany(routeArg1, routeArg2)

	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RestRoute", "GetMany")

}

// ConvertToInt invoke Route.ConvertToInt using the request body as a json payload.
// ConvertToInt an arg from the route.
func (t *RestRoute) ConvertToInt(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RestRoute", "ConvertToInt")

	xxRouteVars := mux.Vars(r)
	var routeArg1 int
	if _, ok := xxRouteVars["arg1"]; ok {
		xxTmprouteArg1 := xxRouteVars["arg1"]
		t.Log.Handle(w, r, nil, "input", "route", "arg1", xxTmprouteArg1, "RestRoute", "ConvertToInt")
		{
			var err error
			routeArg1, err = strconv.Atoi(xxTmprouteArg1)

			if err != nil {

				t.Log.Handle(w, r, err, "route", "error", "RestRoute", "ConvertToInt")
				http.Error(w, err.Error(), http.StatusInternalServerError)

				return
			}

		}

	}

	t.embed.ConvertToInt(routeArg1)

	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RestRoute", "ConvertToInt")

}

// ConvertToBool invoke Route.ConvertToBool using the request body as a json payload.
// ConvertToBool an arg from the route.
func (t *RestRoute) ConvertToBool(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RestRoute", "ConvertToBool")

	xxRouteVars := mux.Vars(r)
	var routeArg1 bool
	if _, ok := xxRouteVars["arg1"]; ok {
		xxTmprouteArg1 := xxRouteVars["arg1"]
		t.Log.Handle(w, r, nil, "input", "route", "arg1", xxTmprouteArg1, "RestRoute", "ConvertToBool")
		{
			var err error
			routeArg1, err = strconv.ParseBool(xxTmprouteArg1)

			if err != nil {

				t.Log.Handle(w, r, err, "route", "error", "RestRoute", "ConvertToBool")
				http.Error(w, err.Error(), http.StatusInternalServerError)

				return
			}

		}

	}

	t.embed.ConvertToBool(routeArg1)

	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RestRoute", "ConvertToBool")

}

// MaybeGet invoke Route.MaybeGet using the request body as a json payload.
// MaybeGet an arg from the route if it exists.
func (t *RestRoute) MaybeGet(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RestRoute", "MaybeGet")

	xxRouteVars := mux.Vars(r)
	var routeArg1 *string
	if _, ok := xxRouteVars["arg1"]; ok {
		xxTmprouteArg1 := xxRouteVars["arg1"]
		t.Log.Handle(w, r, nil, "input", "route", "arg1", xxTmprouteArg1, "RestRoute", "MaybeGet")
		routeArg1 = &xxTmprouteArg1
	}

	t.embed.MaybeGet(routeArg1)

	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RestRoute", "MaybeGet")

}

// RestRouteDescriptor describe a *RestRoute
type RestRouteDescriptor struct {
	ggt.TypeDescriptor
	about               *RestRoute
	methodGetAll        *ggt.MethodDescriptor
	methodGetOne        *ggt.MethodDescriptor
	methodGetMany       *ggt.MethodDescriptor
	methodConvertToInt  *ggt.MethodDescriptor
	methodConvertToBool *ggt.MethodDescriptor
	methodMaybeGet      *ggt.MethodDescriptor
}

// NewRestRouteDescriptor describe a *RestRoute
func NewRestRouteDescriptor(about *RestRoute) *RestRouteDescriptor {
	ret := &RestRouteDescriptor{about: about}
	ret.methodGetAll = &ggt.MethodDescriptor{
		Name:    "GetAll",
		Handler: about.GetAll,
		Route:   "GetAll",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodGetAll)
	ret.methodGetOne = &ggt.MethodDescriptor{
		Name:    "GetOne",
		Handler: about.GetOne,
		Route:   "GetOne",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodGetOne)
	ret.methodGetMany = &ggt.MethodDescriptor{
		Name:    "GetMany",
		Handler: about.GetMany,
		Route:   "GetMany",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodGetMany)
	ret.methodConvertToInt = &ggt.MethodDescriptor{
		Name:    "ConvertToInt",
		Handler: about.ConvertToInt,
		Route:   "ConvertToInt",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodConvertToInt)
	ret.methodConvertToBool = &ggt.MethodDescriptor{
		Name:    "ConvertToBool",
		Handler: about.ConvertToBool,
		Route:   "ConvertToBool",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodConvertToBool)
	ret.methodMaybeGet = &ggt.MethodDescriptor{
		Name:    "MaybeGet",
		Handler: about.MaybeGet,
		Route:   "MaybeGet",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodMaybeGet)
	return ret
}

// GetAll returns a MethodDescriptor
func (t *RestRouteDescriptor) GetAll() *ggt.MethodDescriptor { return t.methodGetAll }

// GetOne returns a MethodDescriptor
func (t *RestRouteDescriptor) GetOne() *ggt.MethodDescriptor { return t.methodGetOne }

// GetMany returns a MethodDescriptor
func (t *RestRouteDescriptor) GetMany() *ggt.MethodDescriptor { return t.methodGetMany }

// ConvertToInt returns a MethodDescriptor
func (t *RestRouteDescriptor) ConvertToInt() *ggt.MethodDescriptor { return t.methodConvertToInt }

// ConvertToBool returns a MethodDescriptor
func (t *RestRouteDescriptor) ConvertToBool() *ggt.MethodDescriptor { return t.methodConvertToBool }

// MaybeGet returns a MethodDescriptor
func (t *RestRouteDescriptor) MaybeGet() *ggt.MethodDescriptor { return t.methodMaybeGet }
