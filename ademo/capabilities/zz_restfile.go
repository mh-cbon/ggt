package capable

// file generated by
// github.com/mh-cbon/ggt
// do not edit

import (
	ggt "github.com/mh-cbon/ggt/lib"
	"io"
	"mime/multipart"
	"net/http"
	"strconv"
)

var xx9f40dab66c1c7bccec3ad3af17a534a0befb4bac = strconv.Atoi
var xxf9d9fbef3014cee7ae352c64da6fd92731808c0f = io.Copy
var xxffee6461fa1d325cd1982864f557156c3a9168fb = http.StatusOK

// RestFile is an httper of File.
// File ...
type RestFile struct {
	embed   File
	Log     ggt.HTTPLogger
	Session ggt.SessionStoreProvider
	Upload  ggt.Uploader
}

// NewRestFile constructs an httper of File
func NewRestFile(embed File) *RestFile {
	ret := &RestFile{
		embed:   embed,
		Log:     &ggt.VoidLog{},
		Session: &ggt.VoidSession{},
		Upload:  &ggt.FileProvider{},
	}
	ret.Log.Handle(nil, nil, nil, "constructor", "RestFile")
	return ret
}

// ReadOneFile invoke File.ReadOneFile using the request body as a json payload.
// ReadOneFile ...
func (t *RestFile) ReadOneFile(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RestFile", "ReadOneFile")

	{
		err := r.ParseForm()

		if err != nil {

			t.Log.Handle(w, r, err, "parseform", "error", "RestFile", "ReadOneFile")
			http.Error(w, err.Error(), http.StatusInternalServerError)

			return
		}

		uploadErr := t.Upload.Check(r, w)

		if uploadErr != nil {

			t.Log.Handle(w, r, uploadErr, "max-size", "error", "RestFile", "ReadOneFile")
			http.Error(w, uploadErr.Error(), http.StatusInternalServerError)

			return
		}

	}
	var fileName io.Reader
	{
		if fheaders, ok := r.MultipartForm.File["name"]; ok {
			for _, hdr := range fheaders {
				var infile multipart.File
				infile, uploadErr := hdr.Open()

				if uploadErr != nil {

					t.Log.Handle(w, r, uploadErr, "req", "file", "open", "error", "RestFile", "ReadOneFile")
					http.Error(w, uploadErr.Error(), http.StatusInternalServerError)

					return
				}

				defer infile.Close()
				fileName = infile.(io.Reader)
				break
			}
		}
	}

	t.embed.ReadOneFile(fileName)
	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RestFile", "ReadOneFile")
}

// ReadOneTmpFile invoke File.ReadOneTmpFile using the request body as a json payload.
// ReadOneTmpFile ...
func (t *RestFile) ReadOneTmpFile(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RestFile", "ReadOneTmpFile")

	{
		err := r.ParseForm()

		if err != nil {

			t.Log.Handle(w, r, err, "parseform", "error", "RestFile", "ReadOneTmpFile")
			http.Error(w, err.Error(), http.StatusInternalServerError)

			return
		}

		uploadErr := t.Upload.Check(r, w)

		if uploadErr != nil {

			t.Log.Handle(w, r, uploadErr, "max-size", "error", "RestFile", "ReadOneTmpFile")
			http.Error(w, uploadErr.Error(), http.StatusInternalServerError)

			return
		}

	}
	var fileName ggt.File
	{
		f, uploadErr := t.Upload.Get(r, w, "name")

		if uploadErr != nil {

			t.Log.Handle(w, r, uploadErr, "req", "file", "open", "error", "RestFile", "ReadOneTmpFile")
			http.Error(w, uploadErr.Error(), http.StatusInternalServerError)

			return
		}

		fileName = f
	}

	t.embed.ReadOneTmpFile(fileName)
	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RestFile", "ReadOneTmpFile")
}

// ReadMany invoke File.ReadMany using the request body as a json payload.
// ReadMany ...
func (t *RestFile) ReadMany(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RestFile", "ReadMany")

	{
		err := r.ParseForm()

		if err != nil {

			t.Log.Handle(w, r, err, "parseform", "error", "RestFile", "ReadMany")
			http.Error(w, err.Error(), http.StatusInternalServerError)

			return
		}

		uploadErr := t.Upload.Check(r, w)

		if uploadErr != nil {

			t.Log.Handle(w, r, uploadErr, "max-size", "error", "RestFile", "ReadMany")
			http.Error(w, uploadErr.Error(), http.StatusInternalServerError)

			return
		}

	}
	var fileName ggt.File
	{
		f, uploadErr := t.Upload.Get(r, w, "name")

		if uploadErr != nil {

			t.Log.Handle(w, r, uploadErr, "req", "file", "open", "error", "RestFile", "ReadMany")
			http.Error(w, uploadErr.Error(), http.StatusInternalServerError)

			return
		}

		fileName = f
	}
	var fileName2 ggt.File
	{
		f, uploadErr := t.Upload.Get(r, w, "name2")

		if uploadErr != nil {

			t.Log.Handle(w, r, uploadErr, "req", "file", "open", "error", "RestFile", "ReadMany")
			http.Error(w, uploadErr.Error(), http.StatusInternalServerError)

			return
		}

		fileName2 = f
	}

	t.embed.ReadMany(fileName, fileName2)
	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RestFile", "ReadMany")
}

// ReadSlice invoke File.ReadSlice using the request body as a json payload.
// ReadSlice ...
func (t *RestFile) ReadSlice(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RestFile", "ReadSlice")

	{
		err := r.ParseForm()

		if err != nil {

			t.Log.Handle(w, r, err, "parseform", "error", "RestFile", "ReadSlice")
			http.Error(w, err.Error(), http.StatusInternalServerError)

			return
		}

		uploadErr := t.Upload.Check(r, w)

		if uploadErr != nil {

			t.Log.Handle(w, r, uploadErr, "max-size", "error", "RestFile", "ReadSlice")
			http.Error(w, uploadErr.Error(), http.StatusInternalServerError)

			return
		}

	}
	var fileName []io.Reader
	{
		if fheaders, ok := r.MultipartForm.File["name"]; ok {
			for _, hdr := range fheaders {
				var infile multipart.File
				infile, uploadErr := hdr.Open()

				if uploadErr != nil {

					t.Log.Handle(w, r, uploadErr, "req", "file", "open", "error", "RestFile", "ReadSlice")
					http.Error(w, uploadErr.Error(), http.StatusInternalServerError)

					return
				}

				defer infile.Close()
				fileName = append(fileName, infile.(io.Reader))
			}
		}
	}
	var fileName2 []ggt.File
	{
		f, uploadErr := t.Upload.GetSlice(r, w, "name2")

		if uploadErr != nil {

			t.Log.Handle(w, r, uploadErr, "req", "file", "open", "error", "RestFile", "ReadSlice")
			http.Error(w, uploadErr.Error(), http.StatusInternalServerError)

			return
		}

		fileName2 = f
	}

	t.embed.ReadSlice(fileName, fileName2)
	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RestFile", "ReadSlice")
}

// ReadAll invoke File.ReadAll using the request body as a json payload.
// ReadAll ...
func (t *RestFile) ReadAll(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RestFile", "ReadAll")

	{
		err := r.ParseForm()

		if err != nil {

			t.Log.Handle(w, r, err, "parseform", "error", "RestFile", "ReadAll")
			http.Error(w, err.Error(), http.StatusInternalServerError)

			return
		}

		uploadErr := t.Upload.Check(r, w)

		if uploadErr != nil {

			t.Log.Handle(w, r, uploadErr, "max-size", "error", "RestFile", "ReadAll")
			http.Error(w, uploadErr.Error(), http.StatusInternalServerError)

			return
		}

	}
	var fileValues []io.Reader
	{
		for _, fheaders := range r.MultipartForm.File {
			for _, hdr := range fheaders {
				var upload multipart.File
				upload, uploadErr := hdr.Open()

				if uploadErr != nil {

					t.Log.Handle(w, r, uploadErr, "req", "file", "open", "error", "RestFile", "ReadAll")
					http.Error(w, uploadErr.Error(), http.StatusInternalServerError)

					return
				}

				defer upload.Close()
				fileValues = append(fileValues, upload.(io.Reader))
			}
		}
	}

	t.embed.ReadAll(fileValues)
	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RestFile", "ReadAll")
}

// ReadAll2 invoke File.ReadAll2 using the request body as a json payload.
// ReadAll2 ...
func (t *RestFile) ReadAll2(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RestFile", "ReadAll2")

	{
		err := r.ParseForm()

		if err != nil {

			t.Log.Handle(w, r, err, "parseform", "error", "RestFile", "ReadAll2")
			http.Error(w, err.Error(), http.StatusInternalServerError)

			return
		}

		uploadErr := t.Upload.Check(r, w)

		if uploadErr != nil {

			t.Log.Handle(w, r, uploadErr, "max-size", "error", "RestFile", "ReadAll2")
			http.Error(w, uploadErr.Error(), http.StatusInternalServerError)

			return
		}

	}
	var fileValues []ggt.File
	{
		f, uploadErr := t.Upload.GetAll(r, w)

		if uploadErr != nil {

			t.Log.Handle(w, r, uploadErr, "req", "file", "open", "error", "RestFile", "ReadAll2")
			http.Error(w, uploadErr.Error(), http.StatusInternalServerError)

			return
		}

		fileValues = f
	}

	t.embed.ReadAll2(fileValues)
	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RestFile", "ReadAll2")
}

// RestFileDescriptor describe a *RestFile
type RestFileDescriptor struct {
	ggt.TypeDescriptor
	about                *RestFile
	methodReadOneFile    *ggt.MethodDescriptor
	methodReadOneTmpFile *ggt.MethodDescriptor
	methodReadMany       *ggt.MethodDescriptor
	methodReadSlice      *ggt.MethodDescriptor
	methodReadAll        *ggt.MethodDescriptor
	methodReadAll2       *ggt.MethodDescriptor
}

// NewRestFileDescriptor describe a *RestFile
func NewRestFileDescriptor(about *RestFile) *RestFileDescriptor {
	ret := &RestFileDescriptor{about: about}
	ret.methodReadOneFile = &ggt.MethodDescriptor{
		Name:    "ReadOneFile",
		Handler: about.ReadOneFile,
		Route:   "ReadOneFile",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodReadOneFile)
	ret.methodReadOneTmpFile = &ggt.MethodDescriptor{
		Name:    "ReadOneTmpFile",
		Handler: about.ReadOneTmpFile,
		Route:   "ReadOneTmpFile",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodReadOneTmpFile)
	ret.methodReadMany = &ggt.MethodDescriptor{
		Name:    "ReadMany",
		Handler: about.ReadMany,
		Route:   "ReadMany",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodReadMany)
	ret.methodReadSlice = &ggt.MethodDescriptor{
		Name:    "ReadSlice",
		Handler: about.ReadSlice,
		Route:   "ReadSlice",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodReadSlice)
	ret.methodReadAll = &ggt.MethodDescriptor{
		Name:    "ReadAll",
		Handler: about.ReadAll,
		Route:   "ReadAll",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodReadAll)
	ret.methodReadAll2 = &ggt.MethodDescriptor{
		Name:    "ReadAll2",
		Handler: about.ReadAll2,
		Route:   "ReadAll2",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodReadAll2)
	return ret
}

// ReadOneFile returns a MethodDescriptor
func (t *RestFileDescriptor) ReadOneFile() *ggt.MethodDescriptor { return t.methodReadOneFile }

// ReadOneTmpFile returns a MethodDescriptor
func (t *RestFileDescriptor) ReadOneTmpFile() *ggt.MethodDescriptor { return t.methodReadOneTmpFile }

// ReadMany returns a MethodDescriptor
func (t *RestFileDescriptor) ReadMany() *ggt.MethodDescriptor { return t.methodReadMany }

// ReadSlice returns a MethodDescriptor
func (t *RestFileDescriptor) ReadSlice() *ggt.MethodDescriptor { return t.methodReadSlice }

// ReadAll returns a MethodDescriptor
func (t *RestFileDescriptor) ReadAll() *ggt.MethodDescriptor { return t.methodReadAll }

// ReadAll2 returns a MethodDescriptor
func (t *RestFileDescriptor) ReadAll2() *ggt.MethodDescriptor { return t.methodReadAll2 }
