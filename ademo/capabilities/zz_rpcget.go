package capable

// file generated by
// github.com/mh-cbon/ggt
// do not edit

import (
	"encoding/json"
	ggt "github.com/mh-cbon/ggt/lib"
	finder "github.com/mh-cbon/service-finder"
	"io"
	"net/http"
	"strconv"
)

var xx00efeff0137224a29086975b39336ddf1e2c440c = strconv.Atoi
var xx224500d9eb17144ee9d18b56f0a36cefebe8fce0 = io.Copy
var xx80436437e20876c92d63a3643d16330ada7afaea = http.StatusOK

// RPCGet is an httper of Get.
// Get ...
type RPCGet struct {
	embed    Get
	Services finder.ServiceFinder
	Log      ggt.HTTPLogger
	Session  ggt.SessionStoreProvider
	Upload   ggt.Uploader
}

// NewRPCGet constructs an httper of Get
func NewRPCGet(embed Get) *RPCGet {
	ret := &RPCGet{
		embed:    embed,
		Services: finder.New(),
		Log:      &ggt.VoidLog{},
		Session:  &ggt.VoidSession{},
		Upload:   &ggt.FileProvider{},
	}
	ret.Log.Handle(nil, nil, nil, "constructor", "RPCGet")
	return ret
}

// GetAll invoke Get.GetAll using the request body as a json payload.
// GetAll values in url query as a map of values
// @route getall
func (t *RPCGet) GetAll(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RPCGet", "GetAll")
	var getValues map[string][]string
	{
		input := struct {
			getValues map[string][]string
		}{}
		decErr := json.NewDecoder(r.Body).Decode(&input)

		if decErr != nil {

			t.Log.Handle(w, r, decErr, "json", "decode", "input", "error", "RPCGet", "GetAll")
			http.Error(w, decErr.Error(), http.StatusInternalServerError)

			return
		}

		getValues = input.getValues
	}

	t.embed.GetAll(getValues)
	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RPCGet", "GetAll")
}

// GetAll2 invoke Get.GetAll2 using the request body as a json payload.
// GetAll2 values in url query as a map of value
// @route getall2
func (t *RPCGet) GetAll2(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RPCGet", "GetAll2")
	var getValues map[string]string
	{
		input := struct {
			getValues map[string]string
		}{}
		decErr := json.NewDecoder(r.Body).Decode(&input)

		if decErr != nil {

			t.Log.Handle(w, r, decErr, "json", "decode", "input", "error", "RPCGet", "GetAll2")
			http.Error(w, decErr.Error(), http.StatusInternalServerError)

			return
		}

		getValues = input.getValues
	}

	t.embed.GetAll2(getValues)
	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RPCGet", "GetAll2")
}

// GetOne invoke Get.GetOne using the request body as a json payload.
// GetOne arg from url query
// @route getone
func (t *RPCGet) GetOne(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RPCGet", "GetOne")
	var getArg1 string
	{
		input := struct {
			getArg1 string
		}{}
		decErr := json.NewDecoder(r.Body).Decode(&input)

		if decErr != nil {

			t.Log.Handle(w, r, decErr, "json", "decode", "input", "error", "RPCGet", "GetOne")
			http.Error(w, decErr.Error(), http.StatusInternalServerError)

			return
		}

		getArg1 = input.getArg1
	}

	t.embed.GetOne(getArg1)
	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RPCGet", "GetOne")
}

// GetMany invoke Get.GetMany using the request body as a json payload.
// GetMany args from url query
// @route getmany
func (t *RPCGet) GetMany(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RPCGet", "GetMany")
	var getArg1 string
	var getArg2 string
	{
		input := struct {
			getArg1 string
			getArg2 string
		}{}
		decErr := json.NewDecoder(r.Body).Decode(&input)

		if decErr != nil {

			t.Log.Handle(w, r, decErr, "json", "decode", "input", "error", "RPCGet", "GetMany")
			http.Error(w, decErr.Error(), http.StatusInternalServerError)

			return
		}

		getArg1 = input.getArg1
		getArg2 = input.getArg2
	}

	t.embed.GetMany(getArg1, getArg2)
	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RPCGet", "GetMany")
}

// ConvertToInt invoke Get.ConvertToInt using the request body as a json payload.
// ConvertToInt an arg from url query
// @route converttoint
func (t *RPCGet) ConvertToInt(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RPCGet", "ConvertToInt")
	var getArg1 int
	{
		input := struct {
			getArg1 int
		}{}
		decErr := json.NewDecoder(r.Body).Decode(&input)

		if decErr != nil {

			t.Log.Handle(w, r, decErr, "json", "decode", "input", "error", "RPCGet", "ConvertToInt")
			http.Error(w, decErr.Error(), http.StatusInternalServerError)

			return
		}

		getArg1 = input.getArg1
	}

	t.embed.ConvertToInt(getArg1)
	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RPCGet", "ConvertToInt")
}

// ConvertToBool invoke Get.ConvertToBool using the request body as a json payload.
// ConvertToBool an arg from url query
// @route converttobool
func (t *RPCGet) ConvertToBool(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RPCGet", "ConvertToBool")
	var getArg1 bool
	{
		input := struct {
			getArg1 bool
		}{}
		decErr := json.NewDecoder(r.Body).Decode(&input)

		if decErr != nil {

			t.Log.Handle(w, r, decErr, "json", "decode", "input", "error", "RPCGet", "ConvertToBool")
			http.Error(w, decErr.Error(), http.StatusInternalServerError)

			return
		}

		getArg1 = input.getArg1
	}

	t.embed.ConvertToBool(getArg1)
	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RPCGet", "ConvertToBool")
}

// ConvertToSlice invoke Get.ConvertToSlice using the request body as a json payload.
// ConvertToSlice an arg from url query
// @route converttoslice
func (t *RPCGet) ConvertToSlice(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RPCGet", "ConvertToSlice")
	var getArg1 []bool
	{
		input := struct {
			getArg1 []bool
		}{}
		decErr := json.NewDecoder(r.Body).Decode(&input)

		if decErr != nil {

			t.Log.Handle(w, r, decErr, "json", "decode", "input", "error", "RPCGet", "ConvertToSlice")
			http.Error(w, decErr.Error(), http.StatusInternalServerError)

			return
		}

		getArg1 = input.getArg1
	}

	t.embed.ConvertToSlice(getArg1)
	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RPCGet", "ConvertToSlice")
}

// MaybeGet invoke Get.MaybeGet using the request body as a json payload.
// MaybeGet an arg if it exists in url query.
// @route maybeget
func (t *RPCGet) MaybeGet(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RPCGet", "MaybeGet")
	var getArg1 *string
	{
		input := struct {
			getArg1 *string
		}{}
		decErr := json.NewDecoder(r.Body).Decode(&input)

		if decErr != nil {

			t.Log.Handle(w, r, decErr, "json", "decode", "input", "error", "RPCGet", "MaybeGet")
			http.Error(w, decErr.Error(), http.StatusInternalServerError)

			return
		}

		getArg1 = input.getArg1
	}

	t.embed.MaybeGet(getArg1)
	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RPCGet", "MaybeGet")
}

// RPCGetDescriptor describe a *RPCGet
type RPCGetDescriptor struct {
	ggt.TypeDescriptor
	about                *RPCGet
	methodGetAll         *ggt.MethodDescriptor
	methodGetAll2        *ggt.MethodDescriptor
	methodGetOne         *ggt.MethodDescriptor
	methodGetMany        *ggt.MethodDescriptor
	methodConvertToInt   *ggt.MethodDescriptor
	methodConvertToBool  *ggt.MethodDescriptor
	methodConvertToSlice *ggt.MethodDescriptor
	methodMaybeGet       *ggt.MethodDescriptor
}

// NewRPCGetDescriptor describe a *RPCGet
func NewRPCGetDescriptor(about *RPCGet) *RPCGetDescriptor {
	ret := &RPCGetDescriptor{about: about}
	ret.methodGetAll = &ggt.MethodDescriptor{
		Name:    "GetAll",
		Handler: about.GetAll,
		Route:   "getall",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodGetAll)
	ret.methodGetAll2 = &ggt.MethodDescriptor{
		Name:    "GetAll2",
		Handler: about.GetAll2,
		Route:   "getall2",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodGetAll2)
	ret.methodGetOne = &ggt.MethodDescriptor{
		Name:    "GetOne",
		Handler: about.GetOne,
		Route:   "getone",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodGetOne)
	ret.methodGetMany = &ggt.MethodDescriptor{
		Name:    "GetMany",
		Handler: about.GetMany,
		Route:   "getmany",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodGetMany)
	ret.methodConvertToInt = &ggt.MethodDescriptor{
		Name:    "ConvertToInt",
		Handler: about.ConvertToInt,
		Route:   "converttoint",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodConvertToInt)
	ret.methodConvertToBool = &ggt.MethodDescriptor{
		Name:    "ConvertToBool",
		Handler: about.ConvertToBool,
		Route:   "converttobool",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodConvertToBool)
	ret.methodConvertToSlice = &ggt.MethodDescriptor{
		Name:    "ConvertToSlice",
		Handler: about.ConvertToSlice,
		Route:   "converttoslice",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodConvertToSlice)
	ret.methodMaybeGet = &ggt.MethodDescriptor{
		Name:    "MaybeGet",
		Handler: about.MaybeGet,
		Route:   "maybeget",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodMaybeGet)
	return ret
}

// GetAll returns a MethodDescriptor
func (t *RPCGetDescriptor) GetAll() *ggt.MethodDescriptor { return t.methodGetAll }

// GetAll2 returns a MethodDescriptor
func (t *RPCGetDescriptor) GetAll2() *ggt.MethodDescriptor { return t.methodGetAll2 }

// GetOne returns a MethodDescriptor
func (t *RPCGetDescriptor) GetOne() *ggt.MethodDescriptor { return t.methodGetOne }

// GetMany returns a MethodDescriptor
func (t *RPCGetDescriptor) GetMany() *ggt.MethodDescriptor { return t.methodGetMany }

// ConvertToInt returns a MethodDescriptor
func (t *RPCGetDescriptor) ConvertToInt() *ggt.MethodDescriptor { return t.methodConvertToInt }

// ConvertToBool returns a MethodDescriptor
func (t *RPCGetDescriptor) ConvertToBool() *ggt.MethodDescriptor { return t.methodConvertToBool }

// ConvertToSlice returns a MethodDescriptor
func (t *RPCGetDescriptor) ConvertToSlice() *ggt.MethodDescriptor { return t.methodConvertToSlice }

// MaybeGet returns a MethodDescriptor
func (t *RPCGetDescriptor) MaybeGet() *ggt.MethodDescriptor { return t.methodMaybeGet }
