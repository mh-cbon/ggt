package capable

// file generated by
// github.com/mh-cbon/ggt
// do not edit

import (
	"github.com/gorilla/mux"
	ggt "github.com/mh-cbon/ggt/lib"
	"io"
	"net/http"
	"strconv"
)

var xx823f5739cf58207161931f728cb2e032f268ab42 = strconv.Atoi
var xxbba276dee07f896b516db08fd667bef01088e0ad = io.Copy
var xx253de98ee8936f17e74b80de8934125614595420 = http.StatusOK

// RestURL is an httper of URL.
// URL is a merge of route, url
type RestURL struct {
	embed   URL
	Log     ggt.HTTPLogger
	Session ggt.SessionStoreProvider
}

// NewRestURL constructs an httper of URL
func NewRestURL(embed URL) *RestURL {
	ret := &RestURL{
		embed:   embed,
		Log:     &ggt.VoidLog{},
		Session: &ggt.VoidSession{},
	}
	ret.Log.Handle(nil, nil, nil, "constructor", "RestURL")
	return ret
}

// GetAll invoke URL.GetAll using the request body as a json payload.
// GetAll  return a merged map of route, url
func (t *RestURL) GetAll(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RestURL", "GetAll")

	xxRouteVars := mux.Vars(r)

	xxURLValues := r.URL.Query()

	var urlValues map[string][]string
	{
		urlValues = map[string][]string{}
		xxTempValue := urlValues
		for k, v := range xxRouteVars {
			if _, ok := xxTempValue[k]; ok {
				xxTempValue[k] = append(xxTempValue[k], v)
			} else {
				xxTempValue[k] = []string{v}
			}
		}
		for k, v := range xxURLValues {
			if _, ok := xxTempValue[k]; ok {
				xxTempValue[k] = append(xxTempValue[k], v...)
			} else {
				xxTempValue[k] = v
			}
		}
	}

	t.embed.GetAll(urlValues)
	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RestURL", "GetAll")
}

// GetAll2 invoke URL.GetAll2 using the request body as a json payload.
// GetAll2 return a merged map of route, url
func (t *RestURL) GetAll2(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RestURL", "GetAll2")

	xxRouteVars := mux.Vars(r)

	xxURLValues := r.URL.Query()

	var urlValues map[string]string
	{
		urlValues = map[string]string{}
		xxTempValue := urlValues
		for k, v := range xxRouteVars {
			if len(v) > 0 {
				xxTempValue[k] = v
			}
		}
		for k, v := range xxURLValues {
			if len(v) > 0 {
				if _, ok := xxTempValue[k]; ok {
					for _, vv := range v {
						if len(vv) > 0 {
							xxTempValue[k] = vv
							break
						}
					}
				} else {
					for _, vv := range v {
						if len(vv) > 0 {
							xxTempValue[k] = vv
							break
						}
					}
				}
			}
		}
	}

	t.embed.GetAll2(urlValues)
	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RestURL", "GetAll2")
}

// GetOne invoke URL.GetOne using the request body as a json payload.
// GetOne return the first value in route, url
func (t *RestURL) GetOne(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RestURL", "GetOne")

	xxRouteVars := mux.Vars(r)

	xxURLValues := r.URL.Query()
	var urlArg1 string
	if _, ok := xxRouteVars["arg1"]; ok {
		xxTmpurlArg1 := xxRouteVars["arg1"]
		urlArg1 = xxTmpurlArg1
	} else if _, ok := xxURLValues["arg1"]; ok {
		xxTmpurlArg1 := xxURLValues.Get("arg1")
		urlArg1 = xxTmpurlArg1
	}

	t.embed.GetOne(urlArg1)
	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RestURL", "GetOne")
}

// GetMany invoke URL.GetMany using the request body as a json payload.
// GetMany return the first value of each parameter in route, url
func (t *RestURL) GetMany(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RestURL", "GetMany")

	xxRouteVars := mux.Vars(r)

	xxURLValues := r.URL.Query()
	var urlArg1 string
	if _, ok := xxRouteVars["arg1"]; ok {
		xxTmpurlArg1 := xxRouteVars["arg1"]
		urlArg1 = xxTmpurlArg1
	} else if _, ok := xxURLValues["arg1"]; ok {
		xxTmpurlArg1 := xxURLValues.Get("arg1")
		urlArg1 = xxTmpurlArg1
	}
	var urlArg2 string
	if _, ok := xxRouteVars["arg2"]; ok {
		xxTmpurlArg2 := xxRouteVars["arg2"]
		urlArg2 = xxTmpurlArg2
	} else if _, ok := xxURLValues["arg2"]; ok {
		xxTmpurlArg2 := xxURLValues.Get("arg2")
		urlArg2 = xxTmpurlArg2
	}

	t.embed.GetMany(urlArg1, urlArg2)
	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RestURL", "GetMany")
}

// ConvertToInt invoke URL.ConvertToInt using the request body as a json payload.
// ConvertToInt an arg
func (t *RestURL) ConvertToInt(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RestURL", "ConvertToInt")

	xxRouteVars := mux.Vars(r)

	xxURLValues := r.URL.Query()
	var urlArg1 int
	if _, ok := xxRouteVars["arg1"]; ok {
		xxTmpurlArg1 := xxRouteVars["arg1"]
		{
			var err error
			urlArg1, err = strconv.Atoi(xxTmpurlArg1)

			if err != nil {

				t.Log.Handle(w, r, err, "url", "route", "error", "RestURL", "ConvertToInt")
				http.Error(w, err.Error(), http.StatusInternalServerError)

				return
			}

		}

	} else if _, ok := xxURLValues["arg1"]; ok {
		xxTmpurlArg1 := xxURLValues.Get("arg1")
		{
			var err error
			urlArg1, err = strconv.Atoi(xxTmpurlArg1)

			if err != nil {

				t.Log.Handle(w, r, err, "url", "get", "error", "RestURL", "ConvertToInt")
				http.Error(w, err.Error(), http.StatusInternalServerError)

				return
			}

		}

	}

	t.embed.ConvertToInt(urlArg1)
	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RestURL", "ConvertToInt")
}

// ConvertToBool invoke URL.ConvertToBool using the request body as a json payload.
// ConvertToBool an arg
func (t *RestURL) ConvertToBool(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RestURL", "ConvertToBool")

	xxRouteVars := mux.Vars(r)

	xxURLValues := r.URL.Query()
	var urlArg1 bool
	if _, ok := xxRouteVars["arg1"]; ok {
		xxTmpurlArg1 := xxRouteVars["arg1"]
		{
			var err error
			urlArg1, err = strconv.ParseBool(xxTmpurlArg1)

			if err != nil {

				t.Log.Handle(w, r, err, "url", "route", "error", "RestURL", "ConvertToBool")
				http.Error(w, err.Error(), http.StatusInternalServerError)

				return
			}

		}

	} else if _, ok := xxURLValues["arg1"]; ok {
		xxTmpurlArg1 := xxURLValues.Get("arg1")
		{
			var err error
			urlArg1, err = strconv.ParseBool(xxTmpurlArg1)

			if err != nil {

				t.Log.Handle(w, r, err, "url", "get", "error", "RestURL", "ConvertToBool")
				http.Error(w, err.Error(), http.StatusInternalServerError)

				return
			}

		}

	}

	t.embed.ConvertToBool(urlArg1)
	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RestURL", "ConvertToBool")
}

// MaybeGet invoke URL.MaybeGet using the request body as a json payload.
// MaybeGet an arg if it exists.
func (t *RestURL) MaybeGet(w http.ResponseWriter, r *http.Request) {
	t.Log.Handle(w, r, nil, "begin", "RestURL", "MaybeGet")

	xxRouteVars := mux.Vars(r)

	xxURLValues := r.URL.Query()
	var urlArg1 *string
	if _, ok := xxRouteVars["arg1"]; ok {
		xxTmpurlArg1 := xxRouteVars["arg1"]
		urlArg1 = &xxTmpurlArg1
	} else if _, ok := xxURLValues["arg1"]; ok {
		xxTmpurlArg1 := xxURLValues.Get("arg1")
		urlArg1 = &xxTmpurlArg1
	}

	t.embed.MaybeGet(urlArg1)
	w.WriteHeader(200)

	t.Log.Handle(w, r, nil, "end", "RestURL", "MaybeGet")
}

// RestURLDescriptor describe a *RestURL
type RestURLDescriptor struct {
	ggt.TypeDescriptor
	about               *RestURL
	methodGetAll        *ggt.MethodDescriptor
	methodGetAll2       *ggt.MethodDescriptor
	methodGetOne        *ggt.MethodDescriptor
	methodGetMany       *ggt.MethodDescriptor
	methodConvertToInt  *ggt.MethodDescriptor
	methodConvertToBool *ggt.MethodDescriptor
	methodMaybeGet      *ggt.MethodDescriptor
}

// NewRestURLDescriptor describe a *RestURL
func NewRestURLDescriptor(about *RestURL) *RestURLDescriptor {
	ret := &RestURLDescriptor{about: about}
	ret.methodGetAll = &ggt.MethodDescriptor{
		Name:    "GetAll",
		Handler: about.GetAll,
		Route:   "GetAll",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodGetAll)
	ret.methodGetAll2 = &ggt.MethodDescriptor{
		Name:    "GetAll2",
		Handler: about.GetAll2,
		Route:   "GetAll2",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodGetAll2)
	ret.methodGetOne = &ggt.MethodDescriptor{
		Name:    "GetOne",
		Handler: about.GetOne,
		Route:   "GetOne",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodGetOne)
	ret.methodGetMany = &ggt.MethodDescriptor{
		Name:    "GetMany",
		Handler: about.GetMany,
		Route:   "GetMany",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodGetMany)
	ret.methodConvertToInt = &ggt.MethodDescriptor{
		Name:    "ConvertToInt",
		Handler: about.ConvertToInt,
		Route:   "ConvertToInt",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodConvertToInt)
	ret.methodConvertToBool = &ggt.MethodDescriptor{
		Name:    "ConvertToBool",
		Handler: about.ConvertToBool,
		Route:   "ConvertToBool",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodConvertToBool)
	ret.methodMaybeGet = &ggt.MethodDescriptor{
		Name:    "MaybeGet",
		Handler: about.MaybeGet,
		Route:   "MaybeGet",
		Methods: []string{},
	}
	ret.TypeDescriptor.Register(ret.methodMaybeGet)
	return ret
}

// GetAll returns a MethodDescriptor
func (t *RestURLDescriptor) GetAll() *ggt.MethodDescriptor { return t.methodGetAll }

// GetAll2 returns a MethodDescriptor
func (t *RestURLDescriptor) GetAll2() *ggt.MethodDescriptor { return t.methodGetAll2 }

// GetOne returns a MethodDescriptor
func (t *RestURLDescriptor) GetOne() *ggt.MethodDescriptor { return t.methodGetOne }

// GetMany returns a MethodDescriptor
func (t *RestURLDescriptor) GetMany() *ggt.MethodDescriptor { return t.methodGetMany }

// ConvertToInt returns a MethodDescriptor
func (t *RestURLDescriptor) ConvertToInt() *ggt.MethodDescriptor { return t.methodConvertToInt }

// ConvertToBool returns a MethodDescriptor
func (t *RestURLDescriptor) ConvertToBool() *ggt.MethodDescriptor { return t.methodConvertToBool }

// MaybeGet returns a MethodDescriptor
func (t *RestURLDescriptor) MaybeGet() *ggt.MethodDescriptor { return t.methodMaybeGet }
